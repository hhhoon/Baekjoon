#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define MAX

/*

베스킨라빈스 31 필승법과 같은 맥락이다.
베스킨 라빈스 31은 무조건 먼저 하는 사람이 이긴다.
1개~3개를 외치는데, 마지막을 외치면 안되므로, 2를 만들어야 하는데,

상대방이 1개를 외치면 나는 3개, 상대방이 2개를 외치면 나는 2개, 
상대방이 3개를 외치면 나는 1개를 외쳐서 4개를 끌고가면

내가 2 + (4의 배수) 를 외치면 결국 2를 외치는 것이므로 이긴다.

30, 26, 22, 18, 14, 10, 6, 2

그래서 먼저 시작할때 31, 30를 외치면 결국 1을 내가 외치게 되서 이긴다.



이 게임은 4를 내면 1을 내고, 1을 내면 4를 내면 반복된다.

16을 낸다면 서로 4를 4번 낸거라 상관 없다.

본인 차례에 적당히 돌을 가져간 '후' 남은 돌을 5의 배수로 만들 수 있다면,
본인은 언제나 마지막 돌을 가져갈 수 있습니다.
*/

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    ll N;
    cin >> N;

    N %= 5;
    if (N==0||N==2){
        cout << "CY";
    }
    else {
        cout << "SK";
    }

    return 0;
}